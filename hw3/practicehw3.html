<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <title>Statistics for Developers</title>
    <link rel="stylesheet" href="../css/styles.css">
    <link href="https://fonts.googleapis.com/css2?family=Roboto:wght@400;500;700&display=swap" rel="stylesheet">
</head>
<body onload="main()">
    <header>
        <div class="home-image"><a href="../index.html"><img src="../images/chart.png" width="45" height="45" alt="Home"></a></div>
        <h1 class="logo">Practice Homework 3 </h1>
    </header>

    <main class="grid-layout-practice">
        <!-- Left Sidebar with navigation menu -->
        <nav class="left-sidebar">
            <ul>
                <li><a href="../hw3/theoryhw3.html">Theory</a></li>
                <li><a href="../hw3/practicehw3.html">Practice</a></li>
            </ul>
        </nav>

        <!-- Main Content Area -->
        <section class="main-content">

            <h1>Stochastic Differential Equation simulator refinement</h1>

            <p>
                Refine your SDE simulator to simulate a continuous time process where we can have an attack (indicated with a jump of +1) at any time with a constant rate of attack. To create the approximation of time continuity subdivide your reference temporal window into numerous intervals of vanishing size dt = 1/n and to each infinitesimal interval assign a probability of a +1 "jump" (attack success) equal to Lambda * dt, where Lambda is a simulation parameter, having the meaning of expected total number of attacks in the reference period.
            </p>
            
                
            <h2>Select the Total Simulation Time, Number of Intervals, Attackers and Rate of Attack</h2>

            <form id="valuesForm" class="">
                <label for="integer1" class="form-label">Total Simulation Time (T)</label>
                <input value=25 type="number" class="form-control" id="integer1" required>

                <label for="integer_n" class="form-label">Total Number of Intervals (n)</label>
                <input value=100 type="number" class="form-control" id="integer_n" required>

                <label for="integer2" class="form-label">Number of attackers</label>
                <input value=50 type="number" class="form-control" id="integer2" required>

                <label for="decimal" class="form-label">Lambda (Rate of Attack)</label>
                <input value=2 type="number" class="form-control" id="decimal" step="0.1" min="0" required>

                <label for="integer3" class="form-label">Intermediate step</label>
                <input value=25 type="number" class="form-control" id="integer3" required>

                <button type="submit" class="my-button">Update Graphs</button>
            </form>
            
        </section>
    </main>
    <div id="chartContainer">
        <div id="singleChartOne">
            <canvas id="myChart"></canvas>
        </div>
        <div id="singleChartTwo">
            <canvas id="mySecondChart"></canvas>
        </div>
        <div id="singleChartFour">
            <canvas id="myFourthChart"></canvas>
        </div>
    </div>
    <div class="grid-layout-expl">
        <nav class="left-sidebar">
        </nav>
        <section class="main-content">

            <h1>Code explanation</h1>
            <h2>Creating Charts</h2>
            <p>
                The addFirstChart() function is responsible for creating the first chart. This chart shows, for each
                attacker, how many servers he managed to penetrate as he tried.<br />
                The x-axis represents the number of servers.<br />
                The y-axis represents the number of successful penetrations.<br />
                Each line corresponds to an attacker and shows how the number of servers penetrated varies as it
                progresses.<br /><br />
                The createSecondChart() function creates the second chart, which shows how many attackers have succeeded
                in penetrating a certain number of servers.<br />
                The x-axis represents the number of successful penetrations (how many servers an attacker managed to
                penetrate).<br />
                The y-axis represents the number of attackers who reached that number of servers.<br /><br />
                <img src="">
                <br /><br />
            <h2>Data Generation</h2>
            This function simulates the attack process.<br />
            For each attacker, an attack against a list of servers is simulated and a calculation is made of how many
            servers it manages to penetrate.<br />
            For each server, a random value between 0 and 1 is generated using Math.random(). If this value is less than
            the probability of success (indicated by the user), the attacker succeeds in penetrating that server.<br />
            The results are stored in a ‘dataset’, where each attacker has a line tracking how many servers he has
            penetrated as the attack progresses.<br /><br />
            <img src="./code-2.png">
            <br /><br />
            <h2>Average calculation</h2>
            This function calculates the average number of servers penetrated by all attackers using recursion.<br />
            The idea is to gradually add up the values of servers penetrated by each attacker and update the average
            step by step using the following formula: \[ \mu_n = \mu_{n-1} + \frac{x_n - \mu_{n-1}}{n} \]<br /><br />
            <img src="./code-3.png">
            <br /><br />
            <h2>HTML form management</h2>
            When the user submits the form, the values entered for the number of servers (integer1), the number of
            attackers (integer2) and the probability of success (p) are collected.<br />
            These values are used to generate the attack data and then update the graphs.<br />
            After the graphs have been created, the value of the average number of servers penetrated by attackers is
            shown.<br /><br />
            <img src="./code-4.png">
            <br /><br />
            </p>
            
        </section>
    </div>
    <script>
        let myChart = null;
        let mySecondChart = null;
        let myFourthChart = null;

        function createFirstChart(servers, attackerDatasets) {

            if (myChart !== null) {
                myChart.destroy();
            }

            const ctx = document.getElementById('myChart').getContext('2d');
            
            myChart = new Chart(ctx, {
                type: 'line',
                data: {
                    labels: servers,
                    datasets: attackerDatasets
                },
                options: {
                    maintainAspectRatio: false,
                    responsive: true,
                    plugins: {
                        legend: {
                            display: false,
                            labels: {
                                color: '#f5f5dc'
                            }
                        }
                    },
                    scales: {
                        x: {
                            display: true,
                            title: {
                                display: false,
                                text: 'servers',
                                color: "#f5f5dc",
                                font: {
                                    family: 'Courier New',
                                    size: 18,
                                },
                            },
                            position: 'bottom',
                            grid: {
                                color: '#54544f'
                            },
                            ticks: {
                                color: '#54544f'
                            }
                        },
                        y: {
                            display: true,
                            title: {
                                display: false,
                                text: 'successful breach',
                                color: "#f5f5dc",
                                font: {
                                    family: 'Courier New',
                                    size: 18,
                                },
                            },
                            position: 'left',
                            max: servers.length + 1,
                            grid: {
                                color: '#54544f'
                            },
                            ticks: {
                                stepSize: 1,
                                color: '#54544f'
                            }
                        },
                    }
                }
            });
        }

        function createSecondChart(servers, penetrationCounts) {
            if (mySecondChart !== null) {
                mySecondChart.destroy();
            }

            const secondCtx = document.getElementById('mySecondChart').getContext('2d');

            let newLabel = servers;

            mySecondChart = new Chart(secondCtx, {

                type: 'bar',
                data: {
                    labels: newLabel,
                    datasets: [{
                        label: "Number of attackers for each level",
                        borderColor: '#00ff9d',
                        borderWidth: 2,
                        radius: 4,
                        pointBackgroundColor: '#00ff9d',
                        backgroundColor: "#00ff9d",
                        fill: true,
                        data: penetrationCounts,
                    }]

                },
                options: {
                    maintainAspectRatio: false,
                    responsive: true,
                    indexAxis: 'y',
                    plugins: {
                        legend: {
                            display: false,
                            labels: {
                                color: '#f5f5dc'
                            }
                        }
                    },
                    scales: {
                        x: {
                            display: false,
                            title: {
                                display: false,
                                text: 'attackers',
                                color: "#f5f5dc",
                                font: {
                                    family: 'Courier New',
                                    size: 18,
                                },
                            },
                            position: 'bottom',
                            grid: {
                                display: false,
                                color: '#f5f5dc'
                            },
                            ticks: {
                                display: false,
                                color: '#f5f5dc',
                                stepSize: 1
                            }
                        },
                        y: {
                            display: false,
                            reverse: true,
                            title: {
                                display: false,
                                text: 'successful breach',
                                color: "#f5f5dc",
                                font: {
                                    family: 'Courier New',
                                    size: 18,
                                },
                            },

                            position: 'left',
                            grid: {
                                display: false,
                                color: '#f5f5dc'
                            },
                            ticks: {
                                callback: function (value, index, values) {
                                    return '';
                                },
                                color: '#f5f5dc',
                            }
                        }
                    }

                },
                maintainAspectRatio: false,
            });
        }

        function createFourthChart(servers, successfulJumps, relativeSuccessfulJumps) {

            if (myFourthChart !== null) {
                myFourthChart.destroy();
            }

            const fourthCtx = document.getElementById('myFourthChart').getContext('2d');
            myFourthChart = new Chart(fourthCtx, {
                type: 'line',
                data: {
                    labels: servers,
                    datasets: [{
                        label: `Absolute frequency`,
                        data: successfulJumps,
                        borderColor: colorRand(),
                        borderWidth: 3,
                        pointRadius: 0,
                        pointHoverRadius: 1,
                    },
                    {
                        label: `Relative frequency`,
                        data: relativeSuccessfulJumps,
                        borderColor: colorRand(),
                        borderWidth: 3,
                        pointRadius: 2,
                        pointHoverRadius: 1,
                    }]
                },
                options: {
                    maintainAspectRatio: false,
                    responsive: true,
                    plugins: {
                        legend: {
                            display: true,
                            labels: {
                                color: '#f5f5dc'
                            }
                        }
                    },
                    scales: {
                        x: {
                            display: true,
                            position: 'bottom',
                            title: {
                                display: true,
                                text: 'servers',
                                color: "#f5f5dc",
                                font: {
                                    family: 'Courier New',
                                    size: 18,
                                },
                            },
                            grid: {
                                color: '#54544f'
                            },
                            ticks: {
                                color: '#54544f'
                            }
                        },
                        y: {
                            display: true,
                            position: 'left',
                            grid: {
                                color: '#54544f'
                            },
                            title: {
                                display: true,
                                text: 'jumps',
                                color: "#f5f5dc",
                                font: {
                                    family: 'Courier New',
                                    size: 18,
                                },
                            },
                            ticks: {
                                stepSize: 1,
                                color: '#54544f'
                            }
                        },
                    }
                }
            });
        }


        function computeMeanAndVariance(penCount, index = 0, currentMean = 0, M2 = 0) {
            if (index >= penCount.length) {
                const variance = index > 1 ? M2 / (index - 1) : 0;
                return { mean: currentMean, variance: variance };
            }

            const value = penCount[index];

            if (!isNaN(value)) {
                const newIndex = index + 1;
                const delta = value - currentMean;
                const newMean = currentMean + delta / newIndex;

                const delta2 = value - newMean;
                const newM2 = M2 + delta * delta2;

                return computeMeanAndVariance(penCount, newIndex, newMean, newM2);
            }

            return computeMeanAndVariance(penCount, index + 1, currentMean, M2);
        }


        function generateDataset(attackers, intervals, lambda, dt) {
            let dataset = [];
            let totalSuccessfulJumps = Array(intervals + 1).fill(0);

            for (let i = 1; i <= attackers.length; i++) {
                let attackerData = [];
                attackerData.push(0);
                let max = 0;

                for (let j = 1; j <= intervals; j++) {

                let randomValue = Math.random();

                if (randomValue < lambda * dt) {
                    max = max + 1;
                    totalSuccessfulJumps[j] += 1;
                }
                attackerData.push(max);
                }

                dataset.push({
                label: `Attacker ${i}`,
                data: attackerData,
                borderColor: colorRand(),
                borderWidth: 2,
                fill: false,
                tension: 0.8,
                pointRadius: 1,
                pointHoverRadius: 1
                });
            }
            const relativeSuccessfulJumps = totalSuccessfulJumps.map((value) => {
                return value / (attackers.length);
            });
            return [dataset, totalSuccessfulJumps, relativeSuccessfulJumps];
        }


        function colorRand() {
            let letters = '0123456789ABCDEF';
            let color = '#';
            for (let i = 0; i < 6; i++) {
                color += letters[Math.floor(Math.random() * 16)];
            }
            return color;
        }

        function getIntermediateDistribution(serversLen, attackerDatasets, step) {
            const penetrationCounts = Array(serversLen - 1).fill(0);
            let attackerPenetrations = []
            attackerDatasets.forEach((attacker) => {
                const finalPenetrations = attacker.data[step];
                attackerPenetrations.push(finalPenetrations)
                penetrationCounts[finalPenetrations - 1]++;
            });
            return [penetrationCounts, attackerPenetrations];
        }


        document.getElementById('valuesForm').addEventListener('submit', function (event) {main()});

        function main(){
            event.preventDefault();
            const integer1 = parseInt(document.getElementById('integer1').value);
            const integern = parseInt(document.getElementById('integer_n').value);
            const integer2 = parseInt(document.getElementById('integer2').value);
            const lambda = parseFloat(document.getElementById('decimal').value);

            if (integer1 < 0 || integern < integer1) {
                event.preventDefault();
            } else {
                const dt = integer1 / integern;
                if (lambda > 1 / dt) {
                    event.preventDefault();
                }
                else {
                    const steps = [];
                    for (let i = 0; i <= integern; i++) {
                        steps.push(i * dt);
                    }
                    const attackers = [];
                    for (let i = 1; i <= integer2; i++) {
                        attackers.push(i);
                    }
                    let [attackerDatasets, successfulJumps, relativeSuccessfulJumps] = generateDataset(attackers, integern, lambda, dt)
                    let [finalDistribution, finalAttackerPenetrations] = getIntermediateDistribution(steps.length, attackerDatasets, integern);
                    const finalMeanAndVariance = computeMeanAndVariance(finalAttackerPenetrations);
                    const finalAvarage = finalMeanAndVariance.mean ? finalMeanAndVariance.mean.toFixed(2) : 0;
                    const finalVariance = finalMeanAndVariance.variance ? finalMeanAndVariance.variance.toFixed(2) : 0;
                    createFirstChart(steps, attackerDatasets);
                    createSecondChart(steps, finalDistribution);
                    createFourthChart(steps, successfulJumps, relativeSuccessfulJumps);

                    document.getElementById('chartContainer').style.display = 'block';

                }
            }
        }
    </script>
        
    </div>
</body>
</html>
