<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <title>Statistics for Developers</title>
    <link rel="stylesheet" href="../css/styles.css">
    <link href="https://fonts.googleapis.com/css2?family=Roboto:wght@400;500;700&display=swap" rel="stylesheet">
</head>
<body onload="main()">
    <header>
        <div class="home-image"><a href="../index.html"><img src="../images/chart.png" width="45" height="45" alt="Home"></a></div>
        <h1 class="logo">Practice Homework 4 </h1>
    </header>

    <main class="grid-layout-practice">
        <!-- Left Sidebar with navigation menu -->
        <nav class="left-sidebar">
            <ul>
                <li><a href="../hw4/theoryhw4.html">Theory</a></li>
                <li><a href="../hw4/practicehw4.html">Practice</a></li>
            </ul>
        </nav>

        <!-- Main Content Area -->
        <section class="main-content">

            <h1>Stochastic Differential Equation simulator refinement</h1>
            <p>
              Refine your stochastic SDE simulator to generate a continuous time, process to represent the scaling limit of
              the random Walk. To create the approximation of time continuity subdivide your reference temporal window into
              vanishing intervals dt and on each infinitesimal interval assign a probability p or p to make a jump of a + or -
              sqrt(dt). Note the significance of the simulation (Donsker invariance principle/ theorem or the functional
              central limit theorem) in relation to the Wiener process.
            </p>
            
                
            <h2>Select the Total Simulation Time, Number of Intervals, Attackers and Rate of Attack</h2>

            <form id="valuesForm" class="">
                <label for="integer1" class="form-label">Total Simulation Time (T)</label>
                <input value=25 type="number" class="form-control" id="integer1" required>

                <label for="integer_n" class="form-label">Total Number of Intervals (n)</label>
                <input value=100 type="number" class="form-control" id="integer_n" required>

                <label for="integer2" class="form-label">Number of attackers</label>
                <input value=50 type="number" class="form-control" id="integer2" required>

                <label for="decimal" class="form-label">Probability</label>
                <input value=0.5 type="number" class="form-control" id="decimal" step="0.1" min="0" max="1" required>

                <label for="integer3" class="form-label">Intermediate step</label>
                <input value=25 type="number" class="form-control" id="integer3" required>

                <button type="submit" class="my-button">Update Graphs</button>
            </form>
            
        </section>
    </main>
    <div id="chartContainer" style="height: 504px;">
        <div id="singleChartOne">
            <canvas id="myChart"></canvas>
        </div>
        <div id="singleChartTwo">
            <canvas id="mySecondChart"></canvas>
        </div>
        <div id="singleChartFour">
            <canvas id="myFourthChart"></canvas>
        </div>
    </div>
    <div class="grid-layout-expl">
        <nav class="left-sidebar">
        </nav>
        <section class="main-content">

            <h1>Code explanation</h1>
            <h2>Creating Charts</h2>
            <p>
                The addFirstChart() function is responsible for creating the first chart. This chart shows, for each
                attacker, how many servers he managed to penetrate as he tried.<br />
                The x-axis represents the number of servers.<br />
                The y-axis represents the number of successful penetrations.<br />
                Each line corresponds to an attacker and shows how the number of servers penetrated varies as it
                progresses.<br /><br />
                The createSecondChart() function creates the second chart, which shows how many attackers have succeeded
                in penetrating a certain number of servers.<br />
                The x-axis represents the number of successful penetrations (how many servers an attacker managed to
                penetrate).<br />
                The y-axis represents the number of attackers who reached that number of servers.<br /><br />
                <img src="">
                <br /><br />
            <h2>Data Generation</h2>
            This function simulates the attack process.<br />
            For each attacker, an attack against a list of servers is simulated and a calculation is made of how many
            servers it manages to penetrate.<br />
            For each server, a random value between 0 and 1 is generated using Math.random(). If this value is less than
            the probability of success (indicated by the user), the attacker succeeds in penetrating that server.<br />
            The results are stored in a ‘dataset’, where each attacker has a line tracking how many servers he has
            penetrated as the attack progresses.<br /><br />
            <img src="./code-2.png">
            <br /><br />
            <h2>Average calculation</h2>
            This function calculates the average number of servers penetrated by all attackers using recursion.<br />
            The idea is to gradually add up the values of servers penetrated by each attacker and update the average
            step by step using the following formula: \[ \mu_n = \mu_{n-1} + \frac{x_n - \mu_{n-1}}{n} \]<br /><br />
            <img src="./code-3.png">
            <br /><br />
            <h2>HTML form management</h2>
            When the user submits the form, the values entered for the number of servers (integer1), the number of
            attackers (integer2) and the probability of success (p) are collected.<br />
            These values are used to generate the attack data and then update the graphs.<br />
            After the graphs have been created, the value of the average number of servers penetrated by attackers is
            shown.<br /><br />
            <img src="./code-4.png">
            <br /><br />
            </p>
            
        </section>
    </div>
    <script>
        let myChart = null;
        let mySecondChart = null;
        let myFourthChart = null;

        function createFirstChart(servers, attackerDatasets) {

            if (myChart !== null) {
                myChart.destroy();
            }

            const ctx = document.getElementById('myChart').getContext('2d');
            
            myChart = new Chart(ctx, {
                type: 'line',
                data: {
                    labels: servers,
                    datasets: attackerDatasets
                },
                options: {
                    maintainAspectRatio: false,
                    responsive: true,
                    plugins: {
                        legend: {
                            display: false,
                            labels: {
                                color: '#f5f5dc'
                            }
                        }
                    },
                    scales: {
                        x: {
                            display: true,
                            title: {
                                display: false,
                                text: 'servers',
                                color: "#f5f5dc",
                                font: {
                                    family: 'Courier New',
                                    size: 18,
                                },
                            },
                            position: 'bottom',
                            grid: {
                                color: '#54544f'
                            },
                            ticks: {
                                color: '#54544f'
                            }
                        },
                        y: {
                            display: true,
                            title: {
                                display: false,
                                text: 'successful breach',
                                color: "#f5f5dc",
                                font: {
                                    family: 'Courier New',
                                    size: 18,
                                },
                            },
                            position: 'left',
                            grid: {
                                color: '#54544f'
                            },
                            ticks: {
                                stepSize: 1,
                                color: '#54544f'
                            }
                        },
                    }
                }
            });
        }


        function computeMeanAndVariance(penCount, index = 0, currentMean = 0, M2 = 0) {
            if (index >= penCount.length) {
                const variance = index > 1 ? M2 / (index - 1) : 0;
                return { mean: currentMean, variance: variance };
            }

            const value = penCount[index];

            if (!isNaN(value)) {
                const newIndex = index + 1;
                const delta = value - currentMean;
                const newMean = currentMean + delta / newIndex;

                const delta2 = value - newMean;
                const newM2 = M2 + delta * delta2;

                return computeMeanAndVariance(penCount, newIndex, newMean, newM2);
            }

            return computeMeanAndVariance(penCount, index + 1, currentMean, M2);
        }


        function generateDataset(attackers, intervals, p, dt) {
            let dataset = [];
            let totalSuccessfulJumps = Array(intervals + 1).fill(0);
            const sqrtDt = Math.sqrt(dt);

            for (let i = 1; i <= attackers.length; i++) {
                let attackerData = [];
                attackerData.push(0);
                let max = 0;

                for (let j = 1; j <= intervals; j++) {

                let randomValue = Math.random();

                if (randomValue < p) {
                    max = max + sqrtDt;
                    totalSuccessfulJumps[j] += 1;
                } else {
                    max = max - sqrtDt;
                }
                attackerData.push(max);
                }

                dataset.push({
                label: `Attacker ${i}`,
                data: attackerData,
                borderColor: colorRand(),
                borderWidth: 2,
                fill: false,
                tension: 0.8,
                pointRadius: 1,
                pointHoverRadius: 1
                });
            }
            const relativeSuccessfulJumps = totalSuccessfulJumps.map((value) => {
                return value / (attackers.length);
            });
            return [dataset, totalSuccessfulJumps, relativeSuccessfulJumps];
        }


        function colorRand() {
            let letters = '0123456789ABCDEF';
            let color = '#';
            for (let i = 0; i < 6; i++) {
                color += letters[Math.floor(Math.random() * 16)];
            }
            return color;
        }

        function getIntermediateDistribution(serversLen, attackerDatasets, step) {
            const penetrationCounts = Array(serversLen * 2 - 1).fill(0);
            let attackerPenetrations = []
            attackerDatasets.forEach((attacker) => {
                const finalPenetrations = attacker.data[step];
                attackerPenetrations.push(finalPenetrations)
                penetrationCounts[finalPenetrations + serversLen - 1]++;
            });
            return [penetrationCounts, attackerPenetrations];
        }


        document.getElementById('valuesForm').addEventListener('submit', function (event) {main()});

        function main(){
            event.preventDefault();
            const integer1 = parseInt(document.getElementById('integer1').value);
            const integern = parseInt(document.getElementById('integer_n').value);
            const integer2 = parseInt(document.getElementById('integer2').value);
            const p = parseFloat(document.getElementById('decimal').value);

            if (integer1 < 0 || integern < integer1) {
                event.preventDefault();
            } else {
                const dt = integer1 / integern;

                const steps = [];
                for (let i = 0; i <= integern; i++) {
                    steps.push(i * dt);
                }
                const attackers = [];
                for (let i = 1; i <= integer2; i++) {
                    attackers.push(i);
                }
                let [attackerDatasets, successfulJumps, relativeSuccessfulJumps] = generateDataset(attackers, integern, p, dt)
                // let [finalDistribution, finalAttackerPenetrations] = getIntermediateDistribution(steps.length, attackerDatasets, integern);
                // const finalMeanAndVariance = computeMeanAndVariance(finalAttackerPenetrations);
                // const finalAvarage = finalMeanAndVariance.mean ? finalMeanAndVariance.mean.toFixed(2) : 0;
                // const finalVariance = finalMeanAndVariance.variance ? finalMeanAndVariance.variance.toFixed(2) : 0;
                createFirstChart(steps, attackerDatasets, Math.sqrt(dt));
                // createSecondChart(steps, finalDistribution);
                // createFourthChart(steps, successfulJumps, relativeSuccessfulJumps);

                document.getElementById('chartContainer').style.display = 'block';
            }
        }
    </script>
        
    </div>
</body>
</html>
